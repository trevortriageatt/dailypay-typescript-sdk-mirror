/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  TransferDestinationCapability,
  TransferDestinationCapability$inboundSchema,
} from "./transferdestinationcapability.js";

/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export const AccountAttributesDepositoryAccountVerificationStatus = {
  VerificationPending: "VERIFICATION_PENDING",
  VerificationFailed: "VERIFICATION_FAILED",
  Verified: "VERIFIED",
} as const;
/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export type AccountAttributesDepositoryAccountVerificationStatus = ClosedEnum<
  typeof AccountAttributesDepositoryAccountVerificationStatus
>;

export type AccountAttributesDepositoryAccountBalances = {
  /**
   * The amount of funds available to be withdrawn from the account.
   *
   * @remarks
   *
   * For earnings_balance-type accounts, the available balance typically
   * equals the current balance less any pending outflows, plus any pending inflows,
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   */
  available: number | null;
  /**
   * The total amount of funds settled in the account.
   *
   * @remarks
   * This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
   * **Special note for Earnings Balance accounts:**
   * If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
   * If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
   * In those cases, the available balance will be 0.
   */
  current: number | null;
  /**
   * A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
   */
  currency: string;
};

export type AccountAttributesDepositoryAccountCapabilities = {
  /**
   * List of the timing and associate fees available when crediting this account as a
   *
   * @remarks
   * transfer destination.
   *
   * Actual fees may differ at the time of transfer; please refer to
   * the transfer preview attribute for the most accurate fee information
   * for any given transfer.
   */
  transferDestination: Array<TransferDestinationCapability>;
};

/**
 * The subtype of the account.
 */
export const AccountAttributesDepositorySubtype = {
  Savings: "SAVINGS",
  Checking: "CHECKING",
} as const;
/**
 * The subtype of the account.
 */
export type AccountAttributesDepositorySubtype = ClosedEnum<
  typeof AccountAttributesDepositorySubtype
>;

/**
 * The banking details of the account and account holder.
 */
export type AccountAttributesDepositoryDepositoryAccountDetails = {
  /**
   * The first name of the account holder.
   */
  firstName: string;
  /**
   * The last name of the account holder.
   */
  lastName: string;
  /**
   * The routing number of the bank that holds this account. Responses from this API that return this number are masked to the last four digits.
   */
  routingNumber: string;
  /**
   * The account number. Responses from this API that return this number are masked to the last four digits.
   */
  accountNumber: string;
};

/**
 * An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
 */
export type Depository = {
  /**
   * A code that indicates the status of an account that is a destination for funds.
   */
  accountVerificationStatus:
    AccountAttributesDepositoryAccountVerificationStatus;
  accountBalances: AccountAttributesDepositoryAccountBalances;
  accountCapabilities: AccountAttributesDepositoryAccountCapabilities;
  /**
   * Display name for this account.
   */
  name: string;
  /**
   * The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
   */
  accountType: "DEPOSITORY";
  /**
   * The subtype of the account.
   */
  subtype: AccountAttributesDepositorySubtype;
  /**
   * The banking details of the account and account holder.
   */
  depositoryAccountDetails: AccountAttributesDepositoryDepositoryAccountDetails;
};

/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export const AccountAttributesEarningsBalanceAccountVerificationStatus = {
  VerificationPending: "VERIFICATION_PENDING",
  VerificationFailed: "VERIFICATION_FAILED",
  Verified: "VERIFIED",
} as const;
/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export type AccountAttributesEarningsBalanceAccountVerificationStatus =
  ClosedEnum<typeof AccountAttributesEarningsBalanceAccountVerificationStatus>;

export type AccountAttributesEarningsBalanceAccountBalances = {
  /**
   * The amount of funds available to be withdrawn from the account.
   *
   * @remarks
   *
   * For earnings_balance-type accounts, the available balance typically
   * equals the current balance less any pending outflows, plus any pending inflows,
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   */
  available: number | null;
  /**
   * The total amount of funds settled in the account.
   *
   * @remarks
   * This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
   * **Special note for Earnings Balance accounts:**
   * If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
   * If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
   * In those cases, the available balance will be 0.
   */
  current: number | null;
  /**
   * A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
   */
  currency: string;
};

export type AccountAttributesEarningsBalanceAccountCapabilities = {
  /**
   * List of the timing and associate fees available when crediting this account as a
   *
   * @remarks
   * transfer destination.
   *
   * Actual fees may differ at the time of transfer; please refer to
   * the transfer preview attribute for the most accurate fee information
   * for any given transfer.
   */
  transferDestination: Array<TransferDestinationCapability>;
};

/**
 * An empty object for earnings balance accounts.
 */
export type Details = {};

/**
 * An account with type `EARNINGS_BALANCE` and subtype `ODP`.
 */
export type EarningsBalanceReadOnly = {
  /**
   * A code that indicates the status of an account that is a destination for funds.
   */
  accountVerificationStatus:
    AccountAttributesEarningsBalanceAccountVerificationStatus;
  accountBalances: AccountAttributesEarningsBalanceAccountBalances;
  accountCapabilities: AccountAttributesEarningsBalanceAccountCapabilities;
  /**
   * Display name for this account.
   */
  name: string;
  /**
   * The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
   */
  accountType: "EARNINGS_BALANCE";
  /**
   * The subtype of the account.
   */
  subtype: "ODP";
  /**
   * An empty object for earnings balance accounts.
   */
  details: Details;
};

/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export const AccountAttributesCardAccountVerificationStatus = {
  VerificationPending: "VERIFICATION_PENDING",
  VerificationFailed: "VERIFICATION_FAILED",
  Verified: "VERIFIED",
} as const;
/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export type AccountAttributesCardAccountVerificationStatus = ClosedEnum<
  typeof AccountAttributesCardAccountVerificationStatus
>;

export type AccountAttributesCardAccountBalances = {
  /**
   * The amount of funds available to be withdrawn from the account.
   *
   * @remarks
   *
   * For earnings_balance-type accounts, the available balance typically
   * equals the current balance less any pending outflows, plus any pending inflows,
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   */
  available: number | null;
  /**
   * The total amount of funds settled in the account.
   *
   * @remarks
   * This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
   * **Special note for Earnings Balance accounts:**
   * If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
   * If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
   * In those cases, the available balance will be 0.
   */
  current: number | null;
  /**
   * A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
   */
  currency: string;
};

export type AccountAttributesCardAccountCapabilities = {
  /**
   * List of the timing and associate fees available when crediting this account as a
   *
   * @remarks
   * transfer destination.
   *
   * Actual fees may differ at the time of transfer; please refer to
   * the transfer preview attribute for the most accurate fee information
   * for any given transfer.
   */
  transferDestination: Array<TransferDestinationCapability>;
};

/**
 * The subtype of the account. Additional subtypes may be added over time
 */
export const AccountAttributesCardSubtype = {
  Debit: "DEBIT",
  Dailypay: "DAILYPAY",
} as const;
/**
 * The subtype of the account. Additional subtypes may be added over time
 */
export type AccountAttributesCardSubtype = ClosedEnum<
  typeof AccountAttributesCardSubtype
>;

/**
 * The banking details of the account and account holder.
 */
export type CardAccountDetails = {
  /**
   * Last four digits of the card number.
   */
  lastFour: string;
  /**
   * The issuer of the card.
   */
  issuer: string;
  /**
   * The first name of the account holder.
   */
  firstName: string;
  /**
   * The last name of the account holder.
   */
  lastName: string;
  /**
   * The month of the expiration date for the card.
   */
  expirationMonth: string;
  /**
   * The year of the expiration date for the card.
   */
  expirationYear: string;
};

/**
 * An account with type `CARD` and subtype `DAILYPAY` or `DEBIT`.
 */
export type Card = {
  /**
   * A code that indicates the status of an account that is a destination for funds.
   */
  accountVerificationStatus: AccountAttributesCardAccountVerificationStatus;
  accountBalances: AccountAttributesCardAccountBalances;
  accountCapabilities: AccountAttributesCardAccountCapabilities;
  /**
   * Display name for this account.
   */
  name: string;
  /**
   * The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
   */
  accountType: "CARD";
  /**
   * The subtype of the account. Additional subtypes may be added over time
   */
  subtype: AccountAttributesCardSubtype;
  /**
   * The banking details of the account and account holder.
   */
  cardAccountDetails: CardAccountDetails;
};

/**
 * The details of the account.
 */
export type AccountAttributes = Card | EarningsBalanceReadOnly | Depository;

/** @internal */
export const AccountAttributesDepositoryAccountVerificationStatus$inboundSchema:
  z.ZodNativeEnum<typeof AccountAttributesDepositoryAccountVerificationStatus> =
    z.nativeEnum(AccountAttributesDepositoryAccountVerificationStatus);

/** @internal */
export const AccountAttributesDepositoryAccountBalances$inboundSchema:
  z.ZodType<AccountAttributesDepositoryAccountBalances, z.ZodTypeDef, unknown> =
    z.object({
      available: z.nullable(z.number().int()),
      current: z.nullable(z.number().int()),
      currency: z.string(),
    });

export function accountAttributesDepositoryAccountBalancesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesDepositoryAccountBalances,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesDepositoryAccountBalances$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesDepositoryAccountBalances' from JSON`,
  );
}

/** @internal */
export const AccountAttributesDepositoryAccountCapabilities$inboundSchema:
  z.ZodType<
    AccountAttributesDepositoryAccountCapabilities,
    z.ZodTypeDef,
    unknown
  > = z.object({
    transfer_destination: z.array(TransferDestinationCapability$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "transfer_destination": "transferDestination",
    });
  });

export function accountAttributesDepositoryAccountCapabilitiesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesDepositoryAccountCapabilities,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesDepositoryAccountCapabilities$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesDepositoryAccountCapabilities' from JSON`,
  );
}

/** @internal */
export const AccountAttributesDepositorySubtype$inboundSchema: z.ZodNativeEnum<
  typeof AccountAttributesDepositorySubtype
> = z.nativeEnum(AccountAttributesDepositorySubtype);

/** @internal */
export const AccountAttributesDepositoryDepositoryAccountDetails$inboundSchema:
  z.ZodType<
    AccountAttributesDepositoryDepositoryAccountDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    first_name: z.string(),
    last_name: z.string(),
    routing_number: z.string(),
    account_number: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "first_name": "firstName",
      "last_name": "lastName",
      "routing_number": "routingNumber",
      "account_number": "accountNumber",
    });
  });

export function accountAttributesDepositoryDepositoryAccountDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesDepositoryDepositoryAccountDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesDepositoryDepositoryAccountDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesDepositoryDepositoryAccountDetails' from JSON`,
  );
}

/** @internal */
export const Depository$inboundSchema: z.ZodType<
  Depository,
  z.ZodTypeDef,
  unknown
> = z.object({
  verification_status:
    AccountAttributesDepositoryAccountVerificationStatus$inboundSchema,
  balances: z.lazy(() =>
    AccountAttributesDepositoryAccountBalances$inboundSchema
  ),
  capabilities: z.lazy(() =>
    AccountAttributesDepositoryAccountCapabilities$inboundSchema
  ),
  name: z.string(),
  account_type: z.literal("DEPOSITORY"),
  subtype: AccountAttributesDepositorySubtype$inboundSchema,
  details: z.lazy(() =>
    AccountAttributesDepositoryDepositoryAccountDetails$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "verification_status": "accountVerificationStatus",
    "balances": "accountBalances",
    "capabilities": "accountCapabilities",
    "account_type": "accountType",
    "details": "depositoryAccountDetails",
  });
});

export function depositoryFromJSON(
  jsonString: string,
): SafeParseResult<Depository, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Depository$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Depository' from JSON`,
  );
}

/** @internal */
export const AccountAttributesEarningsBalanceAccountVerificationStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof AccountAttributesEarningsBalanceAccountVerificationStatus
  > = z.nativeEnum(AccountAttributesEarningsBalanceAccountVerificationStatus);

/** @internal */
export const AccountAttributesEarningsBalanceAccountBalances$inboundSchema:
  z.ZodType<
    AccountAttributesEarningsBalanceAccountBalances,
    z.ZodTypeDef,
    unknown
  > = z.object({
    available: z.nullable(z.number().int()),
    current: z.nullable(z.number().int()),
    currency: z.string(),
  });

export function accountAttributesEarningsBalanceAccountBalancesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesEarningsBalanceAccountBalances,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesEarningsBalanceAccountBalances$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesEarningsBalanceAccountBalances' from JSON`,
  );
}

/** @internal */
export const AccountAttributesEarningsBalanceAccountCapabilities$inboundSchema:
  z.ZodType<
    AccountAttributesEarningsBalanceAccountCapabilities,
    z.ZodTypeDef,
    unknown
  > = z.object({
    transfer_destination: z.array(TransferDestinationCapability$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "transfer_destination": "transferDestination",
    });
  });

export function accountAttributesEarningsBalanceAccountCapabilitiesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesEarningsBalanceAccountCapabilities,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesEarningsBalanceAccountCapabilities$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesEarningsBalanceAccountCapabilities' from JSON`,
  );
}

/** @internal */
export const Details$inboundSchema: z.ZodType<Details, z.ZodTypeDef, unknown> =
  z.object({});

export function detailsFromJSON(
  jsonString: string,
): SafeParseResult<Details, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Details$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Details' from JSON`,
  );
}

/** @internal */
export const EarningsBalanceReadOnly$inboundSchema: z.ZodType<
  EarningsBalanceReadOnly,
  z.ZodTypeDef,
  unknown
> = z.object({
  verification_status:
    AccountAttributesEarningsBalanceAccountVerificationStatus$inboundSchema,
  balances: z.lazy(() =>
    AccountAttributesEarningsBalanceAccountBalances$inboundSchema
  ),
  capabilities: z.lazy(() =>
    AccountAttributesEarningsBalanceAccountCapabilities$inboundSchema
  ),
  name: z.string(),
  account_type: z.literal("EARNINGS_BALANCE"),
  subtype: z.literal("ODP"),
  details: z.lazy(() => Details$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "verification_status": "accountVerificationStatus",
    "balances": "accountBalances",
    "capabilities": "accountCapabilities",
    "account_type": "accountType",
  });
});

export function earningsBalanceReadOnlyFromJSON(
  jsonString: string,
): SafeParseResult<EarningsBalanceReadOnly, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EarningsBalanceReadOnly$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EarningsBalanceReadOnly' from JSON`,
  );
}

/** @internal */
export const AccountAttributesCardAccountVerificationStatus$inboundSchema:
  z.ZodNativeEnum<typeof AccountAttributesCardAccountVerificationStatus> = z
    .nativeEnum(AccountAttributesCardAccountVerificationStatus);

/** @internal */
export const AccountAttributesCardAccountBalances$inboundSchema: z.ZodType<
  AccountAttributesCardAccountBalances,
  z.ZodTypeDef,
  unknown
> = z.object({
  available: z.nullable(z.number().int()),
  current: z.nullable(z.number().int()),
  currency: z.string(),
});

export function accountAttributesCardAccountBalancesFromJSON(
  jsonString: string,
): SafeParseResult<AccountAttributesCardAccountBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesCardAccountBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AccountAttributesCardAccountBalances' from JSON`,
  );
}

/** @internal */
export const AccountAttributesCardAccountCapabilities$inboundSchema: z.ZodType<
  AccountAttributesCardAccountCapabilities,
  z.ZodTypeDef,
  unknown
> = z.object({
  transfer_destination: z.array(TransferDestinationCapability$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "transfer_destination": "transferDestination",
  });
});

export function accountAttributesCardAccountCapabilitiesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesCardAccountCapabilities,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesCardAccountCapabilities$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesCardAccountCapabilities' from JSON`,
  );
}

/** @internal */
export const AccountAttributesCardSubtype$inboundSchema: z.ZodNativeEnum<
  typeof AccountAttributesCardSubtype
> = z.nativeEnum(AccountAttributesCardSubtype);

/** @internal */
export const CardAccountDetails$inboundSchema: z.ZodType<
  CardAccountDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  last_four: z.string(),
  issuer: z.string(),
  first_name: z.string(),
  last_name: z.string(),
  expiration_month: z.string(),
  expiration_year: z.string(),
}).transform((v) => {
  return remap$(v, {
    "last_four": "lastFour",
    "first_name": "firstName",
    "last_name": "lastName",
    "expiration_month": "expirationMonth",
    "expiration_year": "expirationYear",
  });
});

export function cardAccountDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CardAccountDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CardAccountDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CardAccountDetails' from JSON`,
  );
}

/** @internal */
export const Card$inboundSchema: z.ZodType<Card, z.ZodTypeDef, unknown> = z
  .object({
    verification_status:
      AccountAttributesCardAccountVerificationStatus$inboundSchema,
    balances: z.lazy(() => AccountAttributesCardAccountBalances$inboundSchema),
    capabilities: z.lazy(() =>
      AccountAttributesCardAccountCapabilities$inboundSchema
    ),
    name: z.string(),
    account_type: z.literal("CARD"),
    subtype: AccountAttributesCardSubtype$inboundSchema,
    details: z.lazy(() => CardAccountDetails$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "verification_status": "accountVerificationStatus",
      "balances": "accountBalances",
      "capabilities": "accountCapabilities",
      "account_type": "accountType",
      "details": "cardAccountDetails",
    });
  });

export function cardFromJSON(
  jsonString: string,
): SafeParseResult<Card, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Card$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Card' from JSON`,
  );
}

/** @internal */
export const AccountAttributes$inboundSchema: z.ZodType<
  AccountAttributes,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Card$inboundSchema),
  z.lazy(() => EarningsBalanceReadOnly$inboundSchema),
  z.lazy(() => Depository$inboundSchema),
]);

export function accountAttributesFromJSON(
  jsonString: string,
): SafeParseResult<AccountAttributes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AccountAttributes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AccountAttributes' from JSON`,
  );
}
